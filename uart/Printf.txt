
= en =
int printf ( const char * format, ... );
A format specifier follows this prototype:
%[flags][width][.precision][length]specifier

+-----------+-----------------------------------------+---------+
| specifier | Output                                  | Example |
+-----------+-----------------------------------------+---------+
| d or i    | Signed decimal integer                  | 392     |
+-----------+-----------------------------------------+---------+
| u         | Unsigned decimal integer                | 7235    |
+-----------+-----------------------------------------+---------+
| o         | Unsigned octal                          | 610     |
+-----------+-----------------------------------------+---------+
| x         | Unsigned hexadecimal integer            | 7fa     |
+-----------+-----------------------------------------+---------+
| X         | Unsigned hexadecimal integer(uppercase) | 7FA     |
+-----------+-----------------------------------------+---------+
| c         | character                               | a       |
+-----------+-----------------------------------------+---------+
| s         | string of character                     | sample  |
+-----------+-----------------------------------------+---------+
| p         | pointer address                         | b8000000|
+-----------+-----------------------------------------+---------+
| %         | A % followed by another % character \   | %       |
|           |   will write a single % to the stream.  |         |
+-----------+-----------------------------------------+---------+

[More details]:
  1, man 3 printf
  2, http://www.cplusplus.com/reference/cstdio/printf/

= zh_CN ==
% #0 12 .5 L d
%[标志][最小字段宽度][精度][长度修饰符]转换说明符
1, 标志(可选)
+------+-----------------------------------------------------+
| 标志 | 描述                                                |
+------+-----------------------------------------------------+
| -    | 左对齐                                              |
| +    | 以"+"开头的正符号数                                 |
| 空格 | 用"空格"作为正符号数的前缀                          |
| #    | 以"0"开头的8进制数, 或以"0x"/"0X"开头的16进制数     |
| 0    | 用前导"0"在字段宽度内进行填充(包括0/0x/0X). \       |
|      |    如果转换d/i/o/u/x/X,并指定了精度,则"0"可以忽略.  |
+------+-----------------------------------------------------+
[Note]:
    - #:如果出现"#"flag, 自动添加8/16进制数的0/0x/0X前缀.

2, 最小字段宽度(可选)
- 如果字符数量太少, 无法达到最小字段宽度时, 就对字符数量进行填充.
  默认情况, 在字符左侧添加"空格"进行填充.
- 字符宽度可以是整数或者字符"*", 是"*"时, 宽度又下一个参数决定.
[Note]: "*"时宽度由下一个参数决定, 不是下一个格式化字符, e.g:
	printf("%*d", 4, 8); 将输出: 0008

3, 精度(可选)
- 如果转换说明符是d/i/o/u/x/X, 那么精度表示最少数字位数.(数字位数小于精度时添加前导0)
    如果转换说明符是s, 那么精度表示最大字符数.
- 精度由"."和一个整数或者"*"组成
    如果出现"*",精度又下一个参数决定;
    如果只有一个".", 精度为0.

4, 长度修饰符(可选)
- 整数时:
    h -> short
    l -> long
- e/E/f/g/G时:
	L -> long double

